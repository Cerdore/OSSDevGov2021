## LSC进程

​      有了这些基础设施，我们现在可以谈谈实际制作LSC的过程。这大致分为四个阶段（它们之间的界限非常模糊）:

1. 授权
2. 变更的产生
3. 碎片管理
4. 清理

​      通常情况下，这些步骤发生在一个新的系统、类或功能被编写出来之后，但在设计新系统的过程中牢记这些步骤是很重要的。在Google，我们的目标是在设计后续系统时，考虑到旧系统的迁移路径，这样系统维护者就可以自动将用户转移到新系统中。

### 授权

​      我们要求潜在的作者们填写一份简短的文档，解释拟议变更的原因，其对整个代码库的估计影响（即，大型变更将产生多少个较小的碎片）以及可能的审阅者可能回答的任何问题的答案。 此过程还迫使作者考虑如何以FAQ和建议的更改描述的形式向不熟悉的工程师描述更改。 作者还可以从重构API的所有者那里获得“域审查”。

​      然后，这个提案会被转发到一个有十几个人的电子邮件名单上，这些人对整个过程有监督作用。经过讨论，委员会会就如何推进工作给出反馈。例如，委员会做出的最常见的变更之一是将一个LSC的所有代码审查引导到一个 "全局审批人 "那里。许多第一次编写LSC的人倾向于认为本地项目业主应该审查所有的东西，但对于大多数机械LSC来说，让一个专家了解变化的性质并围绕正确审查它建立自动化是更加便宜的。

​      在修改获得批准后，作者可以继续提交其修改。从历史上看，委员会在批准方面一直非常宽松，往往不仅批准某项具体的修改，而且还批准一系列广泛的相关修改。委员会成员可以酌情对明显的改动进行快速处理，而不需要进行充分审议。

​      这个过程的目的是提供监督和升级的途径，而不至于让LSC的作者太过繁琐。委员会还被授权作为对有关LSC的关切或冲突的升级机构：不同意修改的当地业主可以向该小组提出申诉，然后由该小组对任何冲突进行仲裁。在实践中，很少需要这样做。

### 变更的产生

​      在获得必要的批准后，LSC作者将开始制作实际的代码编辑。有时，这些内容可以全面地生成一个大的全局变化，随后将被分割成许多小的独立部分。通常情况下，由于底层版本控制系统的技术限制，修改的规模太大，无法容纳在一个全局修改中。

​      变更的产生过程应该尽可能的自动化，这样当用户退回到旧的使用方式或在变更的代码中出现文本合并冲突时，父级变更可以被更新。偶尔，在技术工具无法生成全局变更的罕见情况下，我们也会将变更的生成分给人类（见第472页的 "案例研究：RoseHub操作"）。尽管这比自动生成变更要耗费更多的人力，但对于时间敏感的应用来说，这使得全局性的变更能够更快发生。

​      请记住，我们对代码库的人类可读性进行了优化，所以无论什么工具生成的修改，我们都希望生成的修改看起来尽可能的像人类生成的修改。这一要求导致了风格指南和自动格式化工具的必要性（见第8章）。

### 分片和提交

​      在全局变化产生之后，作者就开始运行Rosie。Rosie获取一个大的变更，并根据项目边界和所有权规则将其分割成可以原子化提交的变更。然后，它把每个单独的分片变化通过一个独立的测试--邮件-提交管道。Rosie可能是谷歌开发者基础设施其他部分的重度用户，所以它对任何给定的LSC的未完成分片数量设置上限，以较低的优先级运行，并与基础设施的其他部分进行沟通，了解它在我们的共享测试基础设施上产生多少负载是可以接受的。

​      我们在下面会更多地谈论每个分片的具体测试-邮件提交过程。

> ​                                                                                                    **牛与宠物**
>
> ​      当提到分布式计算环境中的单个机器时，我们经常使用 "牛与宠物 "的比喻，但同样的原则可以适用于代码库中的变化。
>
> ​      在谷歌，和大多数组织一样，代码库的典型变更是由从事特定功能或错误修复的个别工程师手工制作的。工程师们可能会花几天或几周的时间来创建、测试和审查一个单一的变更。他们密切了解这个变更，当它最终被提交到主资源库时，他们会感到很自豪。创建这样的变更就像拥有和养育一只喜爱的宠物一样。
>
> ​      相比之下，有效地处理LSCs需要高度的自动化，并产生大量的单独的变更。在这种环境下，我们发现把特定的修改当作牛来对待是很有用的：无名无姓的提交，在任何时候都可能被回滚或以其他方式拒绝，除非整个牛群受到影响，否则代价很小。通常情况下，这种情况发生的原因是测试没有发现的意外问题，或者是像合并冲突这样简单的事情。
>
> ​      对于 "宠物 "提交，不把拒绝放在心上是很难的，但当作为大规模变更的一部分，处理许多变更时，这只是工作的性质。有了自动化，意味着可以以非常低的成本更新工具和产生新的变化，所以偶尔失去几头牛并不是什么问题。

#### 测试

​      每个独立的分片都是通过谷歌的CI框架TAP来测试的。我们运行每一个依赖于特定变化中的文件的测试，这常常给我们的CI系统带来高负荷。

​      这可能听起来很昂贵，但实际上，在我们的代码库中的数百万个测试中，绝大多数碎片影响的测试不到一千。对于那些影响更多的测试，我们可以将它们分组：首先运行所有分片的所有受影响测试的联合，然后对于每个单独的分片，只运行其受影响的测试与那些第一次运行失败的测试的交集。大多数这些联合导致代码库中的几乎每一个测试都被运行，所以向该批分片添加额外的修改几乎是无成本的。

​      运行如此大量的测试的缺点之一是，独立的低概率事件在足够大的规模下几乎是肯定的。脆弱和易碎的测试，如第11章中讨论的那些，通常不会伤害编写和维护它们的团队，对LSC作者来说特别困难。虽然对单个团队的影响相当小，但片状测试会严重影响LSC系统的吞吐量。自动片断检测和消除系统有助于解决这个问题，但要确保编写片断测试的团队承担其成本，这可能是一个持续的努力。

​      根据我们对LSCs作为语义保护、机器生成的变化的经验，我们现在对单个变化的正确性比对近期有任何闪失的测试更有信心 —— 以至于最近闪失的测试现在在通过我们的自动化工具提交时被忽略了。在理论上，这意味着一个单一的碎片可能会导致性能衰退，而这个衰退只能由一个不稳定的测试从不稳定到失败来检测。在实践中，我们很少看到这种情况，所以通过人工沟通而不是自动化来处理它。

​      对于任何LSC进程来说，各个分片应该是可以独立提交的。这意味着它们没有任何相互依赖性，或者说分片机制可以将相互依赖的变更（比如对头文件和其实现的变更）归为一组。就像其他变化一样，大规模的变化分片在被审查和提交之前也必须通过项目特定的检查。

#### 寄送审查者

​      在Rosie通过测试验证了某项变更是安全的之后，它就会将该变更寄送给适当的审查者。在谷歌这样一个拥有数千名工程师的大公司，审查者的发现本身就是一个具有挑战性的问题。回顾第九章，版本库中的代码是用 OWNERS 文件组织的，它列出了对版本库中特定子树有批准权限的用户。Rosie使用一个所有者检测服务来理解这些OWNERS文件，并根据他们审查特定分片的预期能力来衡量每个所有者。如果一个特定的所有者被证明没有反应，Rosie会自动添加额外的审查者，以努力使一个变化得到及时的审查。

​      作为邮寄过程的一部分，Rosie也运行每个项目的预提交工具，这可能会执行额外的检查。对于LSCs，我们有选择地禁用某些检查，例如对非标准的修改描述格式的检查。虽然对特定项目的个别变化很有用，但这种检查是整个代码库的异质性的来源，会给LSC过程增加很大的摩擦。这种异质性是扩展我们流程和系统的障碍，不能指望LSC工具和作者了解每个团队的特殊政策。

​      我们还主动地忽略了预先提交的检查故障，这些故障在有关的变化之前就已经存在了。当在一个单独的项目上工作时，工程师很容易修复这些故障并继续他们原来的工作，但当在谷歌的代码库中制作LSC时，这种技术就无法扩展。本地代码所有者有责任在他们的代码库中没有预先存在的故障，这是他们和基础设施团队之间社会契约的一部分。

#### 审查

​      和其他的修改一样，由Rosie产生的变更被期望通过标准的代码审查过程。在实践中，我们发现本地业主通常不会像对待普通变更那样严格对待LSCs —— 他们太信任产生LSCs的工程师了。理想情况下，这些变化会像其他变化一样被审查，但在实践中，本地项目业主已经开始信任基础设施团队，以至于这些变化往往只被粗略地审查。我们已经开始只把那些需要他们审查的变化发送给本地业主，而不仅仅是批准权限。所有其他的修改都可以交给 "全局审批人"：拥有所有权的人可以批准整个版本库的任何修改。

​      全局审核员可以使用单独的一组基于模式的工具来审核每个更改并自动批准满足其期望的更改，而不是单独查看每个更改。 因此，他们只需要手动检查由于合并冲突或工具故障而异常的一小部分子集，这可以很好地扩展过程。

#### 提交

​      最后，单独修改被提交。与寄送步骤一样，我们确保修改通过各种项目的预提交检查，然后才真正最终提交到仓库。

​      借助Rosie，我们每天可以有效地创建，测试，审查和提交Google所有代码库中成千上万的更改，并使团队能够有效地迁移其用户。 过去曾经是最终决定的技术决策（例如，广泛使用的符号的名称或代码库中流行类的位置）不再是最终决定。

### 清理

​      不同的LSC对 "完成 "有不同的定义，从完全删除一个旧系统到只迁移高价值的引用，让旧的引用有机地消失。几乎在所有情况下，重要的是要有一个系统来防止额外引入大规模变革中努力删除的符号或系统。在谷歌，我们使用第20章和第19章中提到的Tricorder框架，当工程师引入一个废弃对象的新用途时，在审查时进行标记，这被证明是防止倒退的有效方法。我们在第15章中详细讨论了整个废弃过程。

## 总结

​      LSCs构成了谷歌软件工程生态系统的一个重要部分。在设计时，他们开启了更多的可能性，知道一些设计决策不需要像以前那样固定。LSC过程还允许核心基础设施的维护者有能力将谷歌的大片代码库从旧的系统、语言版本和库习语迁移到新的系统，使代码库在空间上和时间上保持一致。而这一切都发生在只有几十名工程师支持数万名其他工程师的情况下。

​      无论你的组织有多大的规模，你都有理由考虑如何在你的源代码集合中进行这类广泛的变更。不管是出于选择还是需要，拥有这种能力将使你的组织在扩大规模时有更大的灵活性，同时使你的源代码随着时间的推移保持可塑性。

## TL;DRs

- LSC过程使我们有可能重新思考某些技术决定的不可改变性。

- 传统的重构模式在大范围内会被打破。
- 制作LSCs意味着养成制作LSCs的习惯。

