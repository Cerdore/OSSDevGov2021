# 第22章 大规模变更

**由Hyrum Wright撰写**。
**编辑：Lisa Carey**

想一想你自己的代码库。一次同时提交可以可靠地更新多少个文件？制约这个数字的因素是什么？你有没有试过做出这么大的改变？在紧急情况下，你能在合理的时间内完成吗？您的最大提交大小与您的代码库的实际大小相比如何？你将如何测试这种变化？在提交变更之前，需要多少人对其进行审核？如果真的做出了改变，你能收回吗？这些问题的答案可能会让你大吃一惊(你认为答案是什么，它们实际上对你的组织是什么)。

在谷歌，我们很久以前就放弃了在我们的代码库中进行大规模改变的想法。我们的观察是，随着代码库和在其中工作的工程师数量的增加，最大的原子变化可能会违反直觉地减少——运行所有受影响的提交前检查和测试变得困难，更不用说确保更改中的每个文件在提交前都是最新的。由于对我们的代码库进行全面的更改变得越来越困难，考虑到我们能够不断改进底层基础设施的普遍愿望，我们必须开发新的方法来推理大规模的更改以及如何实现它们。

在本章中，我们将讨论社交和技术方面的技术，这些技术使我们能够保持大型谷歌代码库的灵活性，并对底层基础设施的变化做出响应。我们还将提供一些我们如何以及在哪里使用这些方法的真实例子。虽然您的代码库可能看起来不像谷歌的，但是理解这些原则并在本地适应它们将有助于您的开发组织扩展，同时仍然能够在您的代码库中进行广泛的更改。

## 什么是大规模的变更

在更进一步之前，我们应该深入研究什么是大规模变更（LSC)。根据我们的经验，LSC是任何一组逻辑上相关的变化，但实际上不能作为一个单一的原子单位提交。这可能是因为它涉及了太多的文件，底层工具无法一次提交所有文件，也可能是因为更改太大，总是会有合并冲突。在许多情况下，LSC是由您的存储库拓扑决定的:如果您的组织使用分布式或联合存储库的集合，在它们之间进行原子性更改在技术上甚至是不可能的。我们将在本章后面更详细地研究原子变化的潜在障碍。

谷歌的物流配送中心几乎总是使用自动化工具生成的。制作LSC的原因各不相同，但这些变化本身通常属于几个基本类别:

•  使用代码库范围的分析工具清理常见的反模式

•  替换不推荐使用的库功能的使用

•  支持底层基础设施改进，如编译器升级

•  将用户从旧系统转移到新系统

在给定的组织中，从事这些特定任务的工程师数量可能很少，但是让他们的客户了解LSC工具和流程是很有用的。就其本质而言，物流服务中心将影响大量客户，而LSC工具很容易缩小到只做几十个相关变更的团队。

特定物流服务中心背后可能有更广泛的激励原因。例如，一个新的语言标准可能会引入一个更有效的习惯用法来完成一个给定的任务，一个内部库接口可能会改变，或者一个新的编译器版本可能需要修复现有的被新版本标记为错误的问题。实际上，谷歌的大多数本地搜索引擎几乎没有功能影响:它们往往是为了清晰、优化或未来兼容性而进行的广泛文本更新。但是LSC理论上并不局限于这种行为保持/重构类的变化。

在所有这些情况下，在一个像谷歌这样大的代码库中，基础设施团队可能经常需要改变成千上万个对旧模式或符号的引用。到目前为止，在最大的案例中，我们已经接触了数百万个参考文献，我们预计该过程将继续顺利扩展。一般来说，我们发现尽早投资并经常投资于工具是有利的，这样可以为许多从事基础设施工作的团队提供物流服务中心。我们还发现，高效的工具也有助于工程师执行较小的变更。同样的工具，可以有效地改变成千上万的文件，也可以缩小到几十个文件。

## 谁来解决大规模变更？

如前所述，构建和管理我们系统的基础设施团队负责执行物流服务中心的大部分工作，但工具和资源在整个公司都可用。如果您跳过了第1章，您可能会想为什么基础设施团队负责这项工作。为什么我们不能引入一个新的类、函数或系统，并规定每个使用旧的类、函数或系统的人都要转到更新的模拟类呢？虽然这在实践中似乎更容易，但由于几个原因，它并没有很好地扩展。

首先，构建和管理底层系统的基础设施团队也是拥有修复对它们的数十万个引用所需的领域知识的团队。使用基础架构的团队不太可能具备处理许多此类迁移的环境，而且指望他们各自重新学习基础架构团队已经掌握的专业知识在全球范围内效率低下。集中化还允许在遇到错误时更快地恢复，因为错误通常属于一小组类别，运行迁移的团队可以有正式或非正式的行动手册来解决它们。

考虑一下做一系列你不理解的半机械变化中的第一个要花多少时间。您可能会花一些时间阅读关于变更的动机和性质，找到一个简单的例子，尝试遵循提供的建议，然后尝试将这些应用到您的本地代码中。对一个组织中的每个团队重复这一点会大大增加执行的总体成本。通过只让几个集中的团队负责物流服务中心，谷歌既将这些成本内部化，又通过使变革更有效地发生来降低成本。

第二，没有人喜欢没有资金支持的任务。即使一个新的系统在本质上比它所取代的系统更好，但这些好处往往分散在整个组织中，因此不太可能重要到让各个团队主动去更新。如果新的系统足够重要，需要迁移到新的系统，那么迁移的成本将由组织中的某个地方来承担。集中迁移和核算其成本，几乎总是比依靠单个团队的有机迁移更快、更便宜。

此外，拥有需要物流服务中心的系统的团队有助于协调激励机制，以确保变革得以完成。根据我们的经验，有机迁移不太可能完全成功，部分原因是工程师在编写新代码时倾向于使用现有代码作为例子。拥有一个在移除负责迁移工作的旧系统方面有既得利益的团队有助于确保它真正完成。尽管为团队提供资金和人员来运行这类迁移看起来像是额外的成本，但实际上它只是将无资金支持的任务所产生的外部性内部化，并带来了规模经济的额外好处。

> 案例学习： 填补坑洞
>
> 尽管谷歌的LSC系统用于高优先级的迁移，但我们也发现，只要它们可用，就能为我们的代码库带来各种小的修复机会，没有它们是不可能的。就像交通基础设施任务包括修建新道路和修复旧道路一样，谷歌的基础设施团队除了开发新系统和将用户转移到新系统上之外，还花费大量时间修复现有代码。
>
> 例如，在我们历史的早期，出现了一个模板库来补充C++标准模板库。这个库被恰当地命名为谷歌模板库，由几个值得实现的头文件组成。由于时间的原因，这些头文件中的一个被命名为stl_util.h，另一个被命名为map-util.h(注意文件名中不同的分隔符)。除了让一致性纯粹主义者发疯之外，这种差异还导致了生产率的降低，工程师必须记住哪个文件使用了哪个分隔符，并且只有在潜在的漫长编译周期后出错时才会发现。
>
> 虽然修复这个单字符的变化似乎毫无意义，尤其是在像谷歌这么大的代码库中，但我们LSC工具和流程的成熟使我们只需要几周的后台工作就可以完成。库作者可以发现并应用这种变化，而不必麻烦这些文件的最终用户，我们能够从数量上减少由这个特定问题导致的构建失败的数量。由此带来的生产率(和幸福感)的提高超过了做出改变所付出的时间。
>
> 随着在我们整个代码库中进行更改的能力的提高，更改的多样性也扩大了，我们可以做出一些工程决策，知道它们在未来不是不可改变的。有时候，补几个坑是值得的。

## 原子变更的障碍

在我们讨论谷歌用来实际影响LSC的过程之前，我们应该谈谈为什么许多类型的更改不能自动提交。在理想的情况下，所有的逻辑变更都可以打包成一个独立的原子提交，可以独立于其他变更进行测试、审查和提交。不幸的是，随着存储库——以及在其中工作的工程师数量——的增长，这种理想变得不太可行。当使用一组分布式或联合存储库时，即使在小规模上，这也是完全不可行的。

### 技术限制

首先，大多数版本控制系统都有随着变更的大小而线性扩展的操作。您的系统可能能够处理小的提交(例如，。几十个文件的数量级)就可以了，但是可能没有足够的内存或处理能力来一次自动提交数千个文件。在集中式虚电路中，提交可以阻止其他写程序(在旧系统中，是读程序)在处理时使用系统，这意味着大型提交会使系统的其他用户停滞。

简而言之，原子性地做出大的改变可能不仅仅是“困难”或“不明智”的:对于给定的基础设施，这可能根本是不可能的。将大的变更分成更小的、独立的块可以避开这些限制，尽管这会使变更的执行更加复杂。

### 合并冲突

随着变更规模的增长，合并冲突的可能性也会增加。我们所知的每个版本控制系统都需要更新和合并，如果中央存储库中存在文件的更新版本，则可能需要手动解析。随着变更中文件数量的增加，遇到合并冲突的可能性也会增加，并且会因在存储库中工作的工程师数量而增加。

如果你的公司很小，你可以在没有人做开发的周末偷偷的修改仓库中的每个文件。或者您可能有一个非正式的系统，通过传递一个虚拟的(甚至是物理的！你的开发团队。在像谷歌这样的大型全球性公司中，这些方法是不可行的:总是有人对存储库进行更改。

变更中的文件越少，合并冲突的概率就越小，因此它们更有可能被提交而没有问题。该属性也适用于以下领域。

### 没有闹鬼的墓地

运营谷歌生产服务的 SREs 有一句口头禅:“没有闹鬼的墓地。在这个意义上，闹鬼的墓地是一个如此古老、迟钝或复杂以至于没有人敢进入的系统。闹鬼的墓地通常是关键业务系统，它们会被及时冻结，因为任何改变它们的尝试都可能导致系统以不可理解的方式失败，给企业带来真正的损失。它们构成了真正的生存风险，并会消耗过多的资源。

然而，闹鬼的墓地不仅仅存在于生产系统中；它们可以在代码库中找到。许多组织都有一些旧的、未维护的软件，它们是由远离团队的人编写的，并且处于一些重要的创收功能的关键路径上。这些系统也在时间上被冻结，层层的官僚机构被建立起来，以防止可能导致不稳定的变化。没人想当翻错位的网络支持工程师二！

LSC进程讨厌代码库的这些部分，因为它们阻止了大规模迁移的完成，阻止了它们所依赖的其他系统的退役，或者阻止了它们所使用的编译器或库的升级。从LSC的角度来看，闹鬼的墓地阻碍了各种有意义的进步。

在谷歌，我们发现与之相反的是好的老式测试。当软件经过彻底测试后，我们可以对其进行任意更改，并且可以放心地知道这些更改是否会被破坏，无论系统的年龄或复杂性如何。编写这些测试需要很大的努力，但它允许像谷歌这样的代码库在很长一段时间内发展，将闹鬼的软件墓地的概念交付给自己的墓地。

只有当大部分工作可以由计算机完成，而不是由人类完成时，LSC才真正发挥作用。就像人类可以处理模糊一样，计算机依赖于一致的环境来将适当的代码转换应用到正确的地方。如果您的组织有许多不同的风险控制系统、持续集成系统、特定于项目的工具或格式指南，很难在整个代码库中进行全面的更改。简化环境以增加一致性将有助于需要在环境中移动的人类和进行自动转换的机器人。

### 异构性

例如，谷歌的许多项目都有预提交测试，配置为在对其代码库进行更改之前运行。这些检查可能非常复杂，从对照白名单检查新的依赖关系，到运行测试，再到确保变更有相关的错误。这些检查中有许多与编写新特性的团队相关，但是对于LSC来说，它们只是增加了不相关的复杂性。

我们已经决定接受这种复杂性，比如运行预提交测试，让它成为我们代码库中的标准。对于其他不一致的地方，我们建议团队在LSC的一部分接触到他们的项目代码时忽略他们的特殊检查。考虑到这些变化给他们的项目带来的好处，大多数团队都很乐意提供帮助。